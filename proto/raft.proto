syntax = "proto3";

package raft;
option go_package = "seminarska/proto/raft;raft";

import "google/protobuf/empty.proto";

// Raft node state
enum NodeState {
  FOLLOWER = 0;
  CANDIDATE = 1;
  LEADER = 2;
}

// Log entry for Raft consensus
message LogEntry {
  int64 term = 1;
  int64 index = 2;
  bytes command = 3;  // serialized command
}

// RequestVote RPC - used by candidates to gather votes
message RequestVoteRequest {
  int64 term = 1;          // candidate's term
  string candidate_id = 2;  // candidate requesting vote
  int64 last_log_index = 3; // index of candidate's last log entry
  int64 last_log_term = 4;  // term of candidate's last log entry
}

message RequestVoteResponse {
  int64 term = 1;       // currentTerm, for candidate to update itself
  bool vote_granted = 2; // true means candidate received vote
}

// AppendEntries RPC - used by leader to replicate log entries and as heartbeat
message AppendEntriesRequest {
  int64 term = 1;           // leader's term
  string leader_id = 2;      // so follower can redirect clients
  int64 prev_log_index = 3;  // index of log entry immediately preceding new ones
  int64 prev_log_term = 4;   // term of prevLogIndex entry
  repeated LogEntry entries = 5; // log entries to store (empty for heartbeat)
  int64 leader_commit = 6;   // leader's commitIndex
}

message AppendEntriesResponse {
  int64 term = 1;    // currentTerm, for leader to update itself
  bool success = 2;  // true if follower contained entry matching prevLogIndex and prevLogTerm
}

// Commands that are replicated through Raft log
message ChainNode {
  string node_id = 1;
  string service_address = 2;    // address for client requests
  string chain_address = 3;      // address for chain replication
  string control_address = 4;    // address for control commands
  bool is_alive = 5;
}

message ClusterState {
  repeated ChainNode nodes = 1;  // ordered list of nodes in the chain
  string head_id = 2;
  string tail_id = 3;
}

// Command types for the state machine
enum CommandType {
  CMD_ADD_NODE = 0;
  CMD_REMOVE_NODE = 1;
  CMD_SET_NODE_STATUS = 2;
  CMD_RECONFIGURE_CHAIN = 3;
}

message Command {
  CommandType type = 1;
  ChainNode node = 2;      // for ADD_NODE, SET_NODE_STATUS
  string node_id = 3;      // for REMOVE_NODE
  ClusterState new_state = 4; // for RECONFIGURE_CHAIN
}

// Health check messages
message HealthCheckRequest {
  string from_node_id = 1;
}

message HealthCheckResponse {
  bool healthy = 1;
  string node_id = 2;
}

// Raft service definition
service RaftService {
  // Raft consensus RPCs
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse);
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
  
  // Client-facing RPCs (redirected to leader)
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeResponse);
  rpc UnregisterNode(UnregisterNodeRequest) returns (google.protobuf.Empty);
  rpc GetClusterInfo(google.protobuf.Empty) returns (ClusterInfoResponse);
}

message RegisterNodeRequest {
  ChainNode node = 1;
}

message RegisterNodeResponse {
  bool success = 1;
  string leader_hint = 2;  // if not leader, hint where leader is
}

message UnregisterNodeRequest {
  string node_id = 1;
}

message ClusterInfoResponse {
  ClusterState state = 1;
  string leader_id = 2;
  int64 term = 3;
}

